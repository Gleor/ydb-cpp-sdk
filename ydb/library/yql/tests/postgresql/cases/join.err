<sql-statement>
--
-- JOIN
-- Test JOIN clauses
--
CREATE TABLE J1_TBL (
  i integer,
  j integer,
  t text
);
</sql-statement>
<sql-statement>
CREATE TABLE J2_TBL (
  i integer,
  k integer
);
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (1, 4, 'one');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (2, 3, 'two');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (3, 2, 'three');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (4, 1, 'four');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (5, 0, 'five');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (6, 6, 'six');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (7, 7, 'seven');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (8, 8, 'eight');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');
</sql-statement>
<sql-statement>
INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (1, -1);
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (2, 2);
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (3, -3);
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (2, 4);
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (5, -5);
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (5, -5);
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (0, NULL);
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (NULL, NULL);
</sql-statement>
<sql-statement>
INSERT INTO J2_TBL VALUES (NULL, 0);
</sql-statement>
<sql-statement>
-- useful in some tests below
create temp table onerow();
</sql-statement>
<sql-statement>
insert into onerow default values;
</sql-statement>
-stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'default_values' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys'. 

<sql-statement>
analyze onerow;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 275
    	analyze onerow;
	^
<sql-statement>
--
-- CORRELATION NAMES
-- Make sure that table/column aliases are supported
-- before diving into more complex join syntax.
--
SELECT *
  FROM J1_TBL AS tx;
</sql-statement>
BackTrace(void**, unsigned long)+29 (0x14033ECD)
TBackTrace::Capture()+30 (0x1403443E)
TWithBackTrace<yexception>::TWithBackTrace<>()+72 (0x13FD0568)
NYT::TNode::TTypeError::TTypeError()+25 (0x144DC3E9)
NYT::TNode::CheckType(NYT::TNode::EType) const+267 (0x144DD9BB)
NYT::TNode::AsString() const+30 (0x144DC53E)
WriteTableToStream(IOutputStream&, TVector<NYT::TNode, std::__y1::allocator<NYT::TNode> > const&, TVector<NYT::TNode, std::__y1::allocator<NYT::TNode> > const&)+830 (0x13EBBB7E)
Main(int, char**)+5748 (0x13EC0FB4)
main+273 (0x13EC2761)
??+0 (0x7FC1F0229D90)
__libc_start_main+128 (0x7FC1F0229E40)
??+0 (0x13E4C029)

(NYT::TNode::TTypeError) library/cpp/yson/node/node.cpp:829: TNode type string_node expected, actual type null

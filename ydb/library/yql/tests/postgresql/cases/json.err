<sql-statement>
-- Strings.
SELECT '""'::json;				-- OK.
</sql-statement>
<sql-statement>
SELECT $$''$$::json;			-- ERROR, single quotes are not allowed
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT $$''$$::json;			-- ERROR, single quotes are not allowed
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "'" is invalid.
CONTEXT:  JSON data, line 1: '...

        	SELECT $$''$$::json;			-- ERROR, single quotes are not allowed
	^
<sql-statement>
SELECT '"abc"'::json;			-- OK
</sql-statement>
<sql-statement>
SELECT '"abc'::json;			-- ERROR, quotes not closed
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"abc'::json;			-- ERROR, quotes not closed
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token ""abc" is invalid.
CONTEXT:  JSON data, line 1: "abc

        	SELECT '"abc'::json;			-- ERROR, quotes not closed
	^
<sql-statement>
SELECT '"abc
def"'::json;					-- ERROR, unescaped newline in string constant
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"abc
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Character with value 0x0a must be escaped.
CONTEXT:  JSON data, line 1: "abc

        	SELECT '"abc
	^
<sql-statement>
SELECT '"\n\"\\"'::json;		-- OK, legal escapes
</sql-statement>
<sql-statement>
SELECT '"\v"'::json;			-- ERROR, not a valid JSON escape
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"\v"'::json;			-- ERROR, not a valid JSON escape
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Escape sequence "\v" is invalid.
CONTEXT:  JSON data, line 1: "\v...

        	SELECT '"\v"'::json;			-- ERROR, not a valid JSON escape
	^
<sql-statement>
-- see json_encoding test for input with unicode escapes
-- Numbers.
SELECT '1'::json;				-- OK
</sql-statement>
<sql-statement>
SELECT '0'::json;				-- OK
</sql-statement>
<sql-statement>
SELECT '01'::json;				-- ERROR, not valid according to JSON spec
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '01'::json;				-- ERROR, not valid according to JSON spec
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "01" is invalid.
CONTEXT:  JSON data, line 1: 01

        	SELECT '01'::json;				-- ERROR, not valid according to JSON spec
	^
<sql-statement>
SELECT '0.1'::json;				-- OK
</sql-statement>
<sql-statement>
SELECT '9223372036854775808'::json;	-- OK, even though it's too large for int8
</sql-statement>
<sql-statement>
SELECT '1e100'::json;			-- OK
</sql-statement>
<sql-statement>
SELECT '1.3e100'::json;			-- OK
</sql-statement>
<sql-statement>
SELECT '1f2'::json;				-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '1f2'::json;				-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "1f2" is invalid.
CONTEXT:  JSON data, line 1: 1f2

        	SELECT '1f2'::json;				-- ERROR
	^
<sql-statement>
SELECT '0.x1'::json;			-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '0.x1'::json;			-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "0.x1" is invalid.
CONTEXT:  JSON data, line 1: 0.x1

        	SELECT '0.x1'::json;			-- ERROR
	^
<sql-statement>
SELECT '1.3ex100'::json;		-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '1.3ex100'::json;		-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "1.3ex100" is invalid.
CONTEXT:  JSON data, line 1: 1.3ex100

        	SELECT '1.3ex100'::json;		-- ERROR
	^
<sql-statement>
-- Arrays.
SELECT '[]'::json;				-- OK
</sql-statement>
<sql-statement>
SELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::json;  -- OK
</sql-statement>
<sql-statement>
SELECT '[1,2]'::json;			-- OK
</sql-statement>
<sql-statement>
SELECT '[1,2,]'::json;			-- ERROR, trailing comma
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,2,]'::json;			-- ERROR, trailing comma
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found "]".
CONTEXT:  JSON data, line 1: [1,2,]

        	SELECT '[1,2,]'::json;			-- ERROR, trailing comma
	^
<sql-statement>
SELECT '[1,2'::json;			-- ERROR, no closing bracket
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,2'::json;			-- ERROR, no closing bracket
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: [1,2

        	SELECT '[1,2'::json;			-- ERROR, no closing bracket
	^
<sql-statement>
SELECT '[1,[2]'::json;			-- ERROR, no closing bracket
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,[2]'::json;			-- ERROR, no closing bracket
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: [1,[2]

        	SELECT '[1,[2]'::json;			-- ERROR, no closing bracket
	^
<sql-statement>
-- Objects.
SELECT '{}'::json;				-- OK
</sql-statement>
<sql-statement>
SELECT '{"abc"}'::json;			-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"}'::json;			-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected ":", but found "}".
CONTEXT:  JSON data, line 1: {"abc"}

        	SELECT '{"abc"}'::json;			-- ERROR, no value
	^
<sql-statement>
SELECT '{"abc":1}'::json;		-- OK
</sql-statement>
<sql-statement>
SELECT '{1:"abc"}'::json;		-- ERROR, keys must be strings
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{1:"abc"}'::json;		-- ERROR, keys must be strings
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected string or "}", but found "1".
CONTEXT:  JSON data, line 1: {1...

        	SELECT '{1:"abc"}'::json;		-- ERROR, keys must be strings
	^
<sql-statement>
SELECT '{"abc",1}'::json;		-- ERROR, wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc",1}'::json;		-- ERROR, wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected ":", but found ",".
CONTEXT:  JSON data, line 1: {"abc",...

        	SELECT '{"abc",1}'::json;		-- ERROR, wrong separator
	^
<sql-statement>
SELECT '{"abc"=1}'::json;		-- ERROR, totally wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"=1}'::json;		-- ERROR, totally wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "=" is invalid.
CONTEXT:  JSON data, line 1: {"abc"=...

        	SELECT '{"abc"=1}'::json;		-- ERROR, totally wrong separator
	^
<sql-statement>
SELECT '{"abc"::1}'::json;		-- ERROR, another wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"::1}'::json;		-- ERROR, another wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found ":".
CONTEXT:  JSON data, line 1: {"abc"::...

        	SELECT '{"abc"::1}'::json;		-- ERROR, another wrong separator
	^
<sql-statement>
SELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::json; -- OK
</sql-statement>
<sql-statement>
SELECT '{"abc":1:2}'::json;		-- ERROR, colon in wrong spot
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc":1:2}'::json;		-- ERROR, colon in wrong spot
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected "," or "}", but found ":".
CONTEXT:  JSON data, line 1: {"abc":1:...

        	SELECT '{"abc":1:2}'::json;		-- ERROR, colon in wrong spot
	^
<sql-statement>
SELECT '{"abc":1,3}'::json;		-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc":1,3}'::json;		-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected string, but found "3".
CONTEXT:  JSON data, line 1: {"abc":1,3...

        	SELECT '{"abc":1,3}'::json;		-- ERROR, no value
	^
<sql-statement>
-- Recursion.
SET max_stack_depth = '100kB';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: max_stack_depth
    	-- Recursion.
	^
<sql-statement>
SELECT repeat('[', 10000)::json;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT repeat('[', 10000)::json;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  stack depth limit exceeded
HINT:  Increase the configuration parameter "max_stack_depth" (currently 100kB), after ensuring the platform's stack depth limit is adequate.

        	SELECT repeat('[', 10000)::json;
	^
<sql-statement>
SELECT repeat('{"a":', 10000)::json;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT repeat('{"a":', 10000)::json;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  stack depth limit exceeded
HINT:  Increase the configuration parameter "max_stack_depth" (currently 100kB), after ensuring the platform's stack depth limit is adequate.

        	SELECT repeat('{"a":', 10000)::json;
	^
<sql-statement>
RESET max_stack_depth;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	RESET max_stack_depth;
	^
<sql-statement>
-- Miscellaneous stuff.
SELECT 'true'::json;			-- OK
</sql-statement>
<sql-statement>
SELECT 'false'::json;			-- OK
</sql-statement>
<sql-statement>
SELECT 'null'::json;			-- OK
</sql-statement>
<sql-statement>
SELECT ' true '::json;			-- OK, even with extra whitespace
</sql-statement>
<sql-statement>
SELECT 'true false'::json;		-- ERROR, too many values
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'true false'::json;		-- ERROR, too many values
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected end of input, but found "false".
CONTEXT:  JSON data, line 1: true false

        	SELECT 'true false'::json;		-- ERROR, too many values
	^
<sql-statement>
SELECT 'true, false'::json;		-- ERROR, too many values
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'true, false'::json;		-- ERROR, too many values
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected end of input, but found ",".
CONTEXT:  JSON data, line 1: true,...

        	SELECT 'true, false'::json;		-- ERROR, too many values
	^
<sql-statement>
SELECT 'truf'::json;			-- ERROR, not a keyword
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'truf'::json;			-- ERROR, not a keyword
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "truf" is invalid.
CONTEXT:  JSON data, line 1: truf

        	SELECT 'truf'::json;			-- ERROR, not a keyword
	^
<sql-statement>
SELECT 'trues'::json;			-- ERROR, not a keyword
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'trues'::json;			-- ERROR, not a keyword
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "trues" is invalid.
CONTEXT:  JSON data, line 1: trues

        	SELECT 'trues'::json;			-- ERROR, not a keyword
	^
<sql-statement>
SELECT ''::json;				-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT ''::json;				-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: 

        	SELECT ''::json;				-- ERROR, no value
	^
<sql-statement>
SELECT '    '::json;			-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '    '::json;			-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1:     

        	SELECT '    '::json;			-- ERROR, no value
	^
<sql-statement>
-- Multi-line JSON input to check ERROR reporting
SELECT '{
		"one": 1,
		"two":"two",
		"three":
		true}'::json; -- OK
</sql-statement>
<sql-statement>
SELECT '{
		"one": 1,
		"two":,"two",  -- ERROR extraneous comma before field "two"
		"three":
		true}'::json;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found ",".
CONTEXT:  JSON data, line 3: 		"two":,...

        	SELECT '{
	^
<sql-statement>
SELECT '{
		"one": 1,
		"two":"two",
		"averyveryveryveryveryveryveryveryveryverylongfieldname":}'::json;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found "}".
CONTEXT:  JSON data, line 4: ...yveryveryveryveryveryveryveryverylongfieldname":}

        	SELECT '{
	^
<sql-statement>
-- ERROR missing value for last field
--constructors
-- array_to_json
SELECT array_to_json(array(select 1 as a));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:22: Error: SublinkExpr: unsupported link type: 6
    	SELECT array_to_json(array(select 1 as a));
	                     ^
<sql-statement>
SELECT array_to_json(array_agg(q),false) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT array_to_json(array_agg(q),false) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
	^
        -stdin-:<main>:1:32: Error: No such column: q
        	SELECT array_to_json(array_agg(q),false) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
	                               ^
<sql-statement>
SELECT array_to_json(array_agg(q),true) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT array_to_json(array_agg(q),true) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
	^
        -stdin-:<main>:1:32: Error: No such column: q
        	SELECT array_to_json(array_agg(q),true) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
	                               ^
<sql-statement>
SELECT array_to_json(array_agg(q),false)
  FROM ( SELECT $$a$$ || x AS b, y AS c,
               ARRAY[ROW(x.*,ARRAY[1,2,3]),
               ROW(y.*,ARRAY[4,5,6])] AS z
         FROM generate_series(1,2) x,
              generate_series(4,5) y) q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:3:16: Error: alternative is not implemented yet : 138
    	               ARRAY[ROW(x.*,ARRAY[1,2,3]),
	               ^
<sql-statement>
SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
	       ^
            -stdin-:<main>:1:22: Error: At function: PgAgg
            	SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
	                     ^
                -stdin-:<main>:1:22: Error: Unable to find an overload for aggregate array_agg with given argument types: (int4)
                	SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
	                     ^
<sql-statement>
SELECT array_to_json('{{1,5},{99,100}}'::int[]);
</sql-statement>
<sql-statement>
-- row_to_json
SELECT row_to_json(row(1,'foo'));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: alternative is not implemented yet : 138
    	SELECT row_to_json(row(1,'foo'));
	       ^
<sql-statement>
SELECT row_to_json(q)
FROM (SELECT $$a$$ || x AS b,
         y AS c,
         ARRAY[ROW(x.*,ARRAY[1,2,3]),
               ROW(y.*,ARRAY[4,5,6])] AS z
      FROM generate_series(1,2) x,
           generate_series(4,5) y) q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:10: Error: alternative is not implemented yet : 138
    	         ARRAY[ROW(x.*,ARRAY[1,2,3]),
	         ^
<sql-statement>
SELECT row_to_json(q,true)
FROM (SELECT $$a$$ || x AS b,
         y AS c,
         ARRAY[ROW(x.*,ARRAY[1,2,3]),
               ROW(y.*,ARRAY[4,5,6])] AS z
      FROM generate_series(1,2) x,
           generate_series(4,5) y) q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:10: Error: alternative is not implemented yet : 138
    	         ARRAY[ROW(x.*,ARRAY[1,2,3]),
	         ^
<sql-statement>
CREATE TEMP TABLE rows AS
SELECT x, 'txt' || x as y
FROM generate_series(1,3) AS x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	CREATE TEMP TABLE rows AS
	^
<sql-statement>
SELECT row_to_json(q,true)
FROM rows q;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.rows
    
<sql-statement>
SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: alternative is not implemented yet : 138
    	SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
	       ^
<sql-statement>
-- anyarray column
analyze rows;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 275
    	-- anyarray column
	^
<sql-statement>
select attname, to_json(histogram_bounds) histogram_bounds
from pg_stats
where tablename = 'rows' and
      schemaname = pg_my_temp_schema()::regnamespace::text
order by 1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.pg_stats
    
<sql-statement>
-- to_json, timestamps
select to_json(timestamp '2014-05-28 12:22:35.614298');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- to_json, timestamps
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select to_json(timestamp '2014-05-28 12:22:35.614298');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc to_json with given argument types: (timestamp)
            	select to_json(timestamp '2014-05-28 12:22:35.614298');
	       ^
<sql-statement>
BEGIN;
</sql-statement>
<sql-statement>
SET LOCAL TIME ZONE 10.5;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: timezone
    	SET LOCAL TIME ZONE 10.5;
	^
<sql-statement>
select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (timestamptz)
            	select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
<sql-statement>
SET LOCAL TIME ZONE -8;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: timezone
    	SET LOCAL TIME ZONE -8;
	^
<sql-statement>
select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (timestamptz)
            	select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
<sql-statement>
COMMIT;
</sql-statement>
<sql-statement>
select to_json(date '2014-05-28');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(date '2014-05-28');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(date '2014-05-28');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (date)
            	select to_json(date '2014-05-28');
	       ^
<sql-statement>
select to_json(date 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(date 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(date 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (date)
            	select to_json(date 'Infinity');
	       ^
<sql-statement>
select to_json(date '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(date '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(date '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (date)
            	select to_json(date '-Infinity');
	       ^
<sql-statement>
select to_json(timestamp 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(timestamp 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(timestamp 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (timestamp)
            	select to_json(timestamp 'Infinity');
	       ^
<sql-statement>
select to_json(timestamp '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(timestamp '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(timestamp '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (timestamp)
            	select to_json(timestamp '-Infinity');
	       ^
<sql-statement>
select to_json(timestamptz 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(timestamptz 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(timestamptz 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (timestamptz)
            	select to_json(timestamptz 'Infinity');
	       ^
<sql-statement>
select to_json(timestamptz '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_json(timestamptz '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_json(timestamptz '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_json with given argument types: (timestamptz)
            	select to_json(timestamptz '-Infinity');
	       ^
<sql-statement>
--json_agg
SELECT json_agg(q)
  FROM ( SELECT $$a$$ || x AS b, y AS c,
               ARRAY[ROW(x.*,ARRAY[1,2,3]),
               ROW(y.*,ARRAY[4,5,6])] AS z
         FROM generate_series(1,2) x,
              generate_series(4,5) y) q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:16: Error: alternative is not implemented yet : 138
    	               ARRAY[ROW(x.*,ARRAY[1,2,3]),
	               ^
<sql-statement>
SELECT json_agg(q ORDER BY x, y)
  FROM rows q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	SELECT json_agg(q ORDER BY x, y)
	       ^
<sql-statement>
UPDATE rows SET x = NULL WHERE x = 1;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys'. 
    
<sql-statement>
SELECT json_agg(q ORDER BY x NULLS FIRST, y)
  FROM rows q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	SELECT json_agg(q ORDER BY x NULLS FIRST, y)
	       ^
<sql-statement>
-- non-numeric output
SELECT row_to_json(q)
FROM (SELECT 'NaN'::float8 AS "float8field") q;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- non-numeric output
	^
        -stdin-:<main>:2:20: Error: No such column: q
        	SELECT row_to_json(q)
	                   ^
<sql-statement>
SELECT row_to_json(q)
FROM (SELECT 'Infinity'::float8 AS "float8field") q;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT row_to_json(q)
	^
        -stdin-:<main>:1:20: Error: No such column: q
        	SELECT row_to_json(q)
	                   ^
<sql-statement>
SELECT row_to_json(q)
FROM (SELECT '-Infinity'::float8 AS "float8field") q;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT row_to_json(q)
	^
        -stdin-:<main>:1:20: Error: No such column: q
        	SELECT row_to_json(q)
	                   ^
<sql-statement>
-- json input
SELECT row_to_json(q)
FROM (SELECT '{"a":1,"b": [2,3,4,"d","e","f"],"c":{"p":1,"q":2}}'::json AS "jsonfield") q;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- json input
	^
        -stdin-:<main>:2:20: Error: No such column: q
        	SELECT row_to_json(q)
	                   ^
<sql-statement>
-- json extraction functions
CREATE TEMP TABLE test_json (
       json_type text,
       test_json json
);
</sql-statement>
<sql-statement>
INSERT INTO test_json VALUES
('scalar','"a scalar"'),
('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
('object','{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
</sql-statement>
<sql-statement>
SELECT test_json -> 'x'
FROM test_json
WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json -> 'x'
FROM test_json
WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> 'x'
FROM test_json
WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json->'field2'
FROM test_json
WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json->>'field2'
FROM test_json
WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json -> 2
FROM test_json
WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json -> 2
FROM test_json
WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> -1
FROM test_json
WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> 2
FROM test_json
WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json->>2
FROM test_json
WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 6 FROM test_json WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 7 FROM test_json WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field4' FROM test_json WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field5' FROM test_json WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field6' FROM test_json WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT json_object_keys(test_json)
FROM test_json
WHERE json_type = 'scalar';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT json_object_keys(test_json)
	       ^
<sql-statement>
SELECT json_object_keys(test_json)
FROM test_json
WHERE json_type = 'array';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT json_object_keys(test_json)
	       ^
<sql-statement>
SELECT json_object_keys(test_json)
FROM test_json
WHERE json_type = 'object';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT json_object_keys(test_json)
	       ^
<sql-statement>
-- test extending object_keys resultset - initial resultset size is 256
select count(*) from
    (select json_object_keys(json_object(array_agg(g)))
     from (select unnest(array['f'||n,n::text])as g
           from generate_series(1,300) as n) x ) y;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:19: Error: Generator functions are not allowed in: SELECT
    	     from (select unnest(array['f'||n,n::text])as g
	                  ^
<sql-statement>
-- nulls
select (test_json->'field3') is null as expect_false
from test_json
where json_type = 'object';
</sql-statement>
<sql-statement>
select (test_json->>'field3') is null as expect_true
from test_json
where json_type = 'object';
</sql-statement>
<sql-statement>
select (test_json->3) is null as expect_false
from test_json
where json_type = 'array';
</sql-statement>
<sql-statement>
select (test_json->>3) is null as expect_true
from test_json
where json_type = 'array';
</sql-statement>
<sql-statement>
-- corner cases
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> null::text;
</sql-statement>
BackTrace(void**, unsigned long)+29 (0x14033ECD)
TBackTrace::Capture()+30 (0x1403443E)
TWithBackTrace<yexception>::TWithBackTrace<>()+72 (0x13FD0568)
NYT::TNode::TTypeError::TTypeError()+25 (0x144DC3E9)
NYT::TNode::CheckType(NYT::TNode::EType) const+267 (0x144DD9BB)
NYT::TNode::AsString() const+30 (0x144DC53E)
WriteTableToStream(IOutputStream&, TVector<NYT::TNode, std::__y1::allocator<NYT::TNode> > const&, TVector<NYT::TNode, std::__y1::allocator<NYT::TNode> > const&)+830 (0x13EBBB7E)
Main(int, char**)+5748 (0x13EC0FB4)
main+273 (0x13EC2761)
??+0 (0x7F33BF829D90)
__libc_start_main+128 (0x7F33BF829E40)
??+0 (0x13E4C029)

(NYT::TNode::TTypeError) library/cpp/yson/node/node.cpp:829: TNode type string_node expected, actual type null

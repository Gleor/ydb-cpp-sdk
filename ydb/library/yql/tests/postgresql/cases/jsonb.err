<sql-statement>
-- Strings.
SELECT '""'::jsonb;				-- OK.
</sql-statement>
<sql-statement>
SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowed
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowed
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "'" is invalid.
CONTEXT:  JSON data, line 1: '...

        	SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowed
	^
<sql-statement>
SELECT '"abc"'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT '"abc'::jsonb;			-- ERROR, quotes not closed
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"abc'::jsonb;			-- ERROR, quotes not closed
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token ""abc" is invalid.
CONTEXT:  JSON data, line 1: "abc

        	SELECT '"abc'::jsonb;			-- ERROR, quotes not closed
	^
<sql-statement>
SELECT '"abc
def"'::jsonb;					-- ERROR, unescaped newline in string constant
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"abc
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Character with value 0x0a must be escaped.
CONTEXT:  JSON data, line 1: "abc

        	SELECT '"abc
	^
<sql-statement>
SELECT '"\n\"\\"'::jsonb;		-- OK, legal escapes
</sql-statement>
<sql-statement>
SELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escape
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escape
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Escape sequence "\v" is invalid.
CONTEXT:  JSON data, line 1: "\v...

        	SELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escape
	^
<sql-statement>
-- see json_encoding test for input with unicode escapes
-- Numbers.
SELECT '1'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '0'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '01'::jsonb;				-- ERROR, not valid according to JSON spec
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '01'::jsonb;				-- ERROR, not valid according to JSON spec
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "01" is invalid.
CONTEXT:  JSON data, line 1: 01

        	SELECT '01'::jsonb;				-- ERROR, not valid according to JSON spec
	^
<sql-statement>
SELECT '0.1'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '9223372036854775808'::jsonb;	-- OK, even though it's too large for int8
</sql-statement>
<sql-statement>
SELECT '1e100'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT '1.3e100'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT '1f2'::jsonb;				-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '1f2'::jsonb;				-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "1f2" is invalid.
CONTEXT:  JSON data, line 1: 1f2

        	SELECT '1f2'::jsonb;				-- ERROR
	^
<sql-statement>
SELECT '0.x1'::jsonb;			-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '0.x1'::jsonb;			-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "0.x1" is invalid.
CONTEXT:  JSON data, line 1: 0.x1

        	SELECT '0.x1'::jsonb;			-- ERROR
	^
<sql-statement>
SELECT '1.3ex100'::jsonb;		-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '1.3ex100'::jsonb;		-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "1.3ex100" is invalid.
CONTEXT:  JSON data, line 1: 1.3ex100

        	SELECT '1.3ex100'::jsonb;		-- ERROR
	^
<sql-statement>
-- Arrays.
SELECT '[]'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::jsonb;  -- OK
</sql-statement>
<sql-statement>
SELECT '[1,2]'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT '[1,2,]'::jsonb;			-- ERROR, trailing comma
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,2,]'::jsonb;			-- ERROR, trailing comma
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found "]".
CONTEXT:  JSON data, line 1: [1,2,]

        	SELECT '[1,2,]'::jsonb;			-- ERROR, trailing comma
	^
<sql-statement>
SELECT '[1,2'::jsonb;			-- ERROR, no closing bracket
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,2'::jsonb;			-- ERROR, no closing bracket
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: [1,2

        	SELECT '[1,2'::jsonb;			-- ERROR, no closing bracket
	^
<sql-statement>
SELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracket
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracket
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: [1,[2]

        	SELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracket
	^
<sql-statement>
-- Objects.
SELECT '{}'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '{"abc"}'::jsonb;			-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"}'::jsonb;			-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected ":", but found "}".
CONTEXT:  JSON data, line 1: {"abc"}

        	SELECT '{"abc"}'::jsonb;			-- ERROR, no value
	^
<sql-statement>
SELECT '{"abc":1}'::jsonb;		-- OK
</sql-statement>
<sql-statement>
SELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be strings
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be strings
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected string or "}", but found "1".
CONTEXT:  JSON data, line 1: {1...

        	SELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be strings
	^
<sql-statement>
SELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected ":", but found ",".
CONTEXT:  JSON data, line 1: {"abc",...

        	SELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separator
	^
<sql-statement>
SELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "=" is invalid.
CONTEXT:  JSON data, line 1: {"abc"=...

        	SELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separator
	^
<sql-statement>
SELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found ":".
CONTEXT:  JSON data, line 1: {"abc"::...

        	SELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separator
	^
<sql-statement>
SELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::jsonb; -- OK
</sql-statement>
<sql-statement>
SELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spot
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spot
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected "," or "}", but found ":".
CONTEXT:  JSON data, line 1: {"abc":1:...

        	SELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spot
	^
<sql-statement>
SELECT '{"abc":1,3}'::jsonb;		-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc":1,3}'::jsonb;		-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected string, but found "3".
CONTEXT:  JSON data, line 1: {"abc":1,3...

        	SELECT '{"abc":1,3}'::jsonb;		-- ERROR, no value
	^
<sql-statement>
-- Recursion.
SET max_stack_depth = '100kB';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: max_stack_depth
    	-- Recursion.
	^
<sql-statement>
SELECT repeat('[', 10000)::jsonb;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT repeat('[', 10000)::jsonb;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  stack depth limit exceeded
HINT:  Increase the configuration parameter "max_stack_depth" (currently 100kB), after ensuring the platform's stack depth limit is adequate.

        	SELECT repeat('[', 10000)::jsonb;
	^
<sql-statement>
SELECT repeat('{"a":', 10000)::jsonb;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT repeat('{"a":', 10000)::jsonb;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  stack depth limit exceeded
HINT:  Increase the configuration parameter "max_stack_depth" (currently 100kB), after ensuring the platform's stack depth limit is adequate.

        	SELECT repeat('{"a":', 10000)::jsonb;
	^
<sql-statement>
RESET max_stack_depth;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	RESET max_stack_depth;
	^
<sql-statement>
-- Miscellaneous stuff.
SELECT 'true'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT 'false'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT 'null'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT ' true '::jsonb;			-- OK, even with extra whitespace
</sql-statement>
<sql-statement>
SELECT 'true false'::jsonb;		-- ERROR, too many values
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'true false'::jsonb;		-- ERROR, too many values
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected end of input, but found "false".
CONTEXT:  JSON data, line 1: true false

        	SELECT 'true false'::jsonb;		-- ERROR, too many values
	^
<sql-statement>
SELECT 'true, false'::jsonb;		-- ERROR, too many values
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'true, false'::jsonb;		-- ERROR, too many values
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected end of input, but found ",".
CONTEXT:  JSON data, line 1: true,...

        	SELECT 'true, false'::jsonb;		-- ERROR, too many values
	^
<sql-statement>
SELECT 'truf'::jsonb;			-- ERROR, not a keyword
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'truf'::jsonb;			-- ERROR, not a keyword
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "truf" is invalid.
CONTEXT:  JSON data, line 1: truf

        	SELECT 'truf'::jsonb;			-- ERROR, not a keyword
	^
<sql-statement>
SELECT 'trues'::jsonb;			-- ERROR, not a keyword
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'trues'::jsonb;			-- ERROR, not a keyword
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "trues" is invalid.
CONTEXT:  JSON data, line 1: trues

        	SELECT 'trues'::jsonb;			-- ERROR, not a keyword
	^
<sql-statement>
SELECT ''::jsonb;				-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT ''::jsonb;				-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: 

        	SELECT ''::jsonb;				-- ERROR, no value
	^
<sql-statement>
SELECT '    '::jsonb;			-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '    '::jsonb;			-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1:     

        	SELECT '    '::jsonb;			-- ERROR, no value
	^
<sql-statement>
-- Multi-line JSON input to check ERROR reporting
SELECT '{
		"one": 1,
		"two":"two",
		"three":
		true}'::jsonb; -- OK
</sql-statement>
<sql-statement>
SELECT '{
		"one": 1,
		"two":,"two",  -- ERROR extraneous comma before field "two"
		"three":
		true}'::jsonb;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found ",".
CONTEXT:  JSON data, line 3: 		"two":,...

        	SELECT '{
	^
<sql-statement>
SELECT '{
		"one": 1,
		"two":"two",
		"averyveryveryveryveryveryveryveryveryverylongfieldname":}'::jsonb;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found "}".
CONTEXT:  JSON data, line 4: ...yveryveryveryveryveryveryveryverylongfieldname":}

        	SELECT '{
	^
<sql-statement>
-- ERROR missing value for last field
-- make sure jsonb is passed through json generators without being escaped
SELECT array_to_json(ARRAY [jsonb '{"a":1}', jsonb '{"b":[2,3]}']);
</sql-statement>
<sql-statement>
-- anyarray column
CREATE TEMP TABLE rows AS
SELECT x, 'txt' || x as y
FROM generate_series(1,3) AS x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	-- anyarray column
	^
<sql-statement>
analyze rows;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 275
    	analyze rows;
	^
<sql-statement>
select attname, to_jsonb(histogram_bounds) histogram_bounds
from pg_stats
where tablename = 'rows' and
      schemaname = pg_my_temp_schema()::regnamespace::text
order by 1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.pg_stats
    
<sql-statement>
-- to_jsonb, timestamps
select to_jsonb(timestamp '2014-05-28 12:22:35.614298');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- to_jsonb, timestamps
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select to_jsonb(timestamp '2014-05-28 12:22:35.614298');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamp)
            	select to_jsonb(timestamp '2014-05-28 12:22:35.614298');
	       ^
<sql-statement>
BEGIN;
</sql-statement>
<sql-statement>
SET LOCAL TIME ZONE 10.5;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: timezone
    	SET LOCAL TIME ZONE 10.5;
	^
<sql-statement>
select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamptz)
            	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
<sql-statement>
SET LOCAL TIME ZONE -8;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: timezone
    	SET LOCAL TIME ZONE -8;
	^
<sql-statement>
select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamptz)
            	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
<sql-statement>
COMMIT;
</sql-statement>
<sql-statement>
select to_jsonb(date '2014-05-28');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(date '2014-05-28');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(date '2014-05-28');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (date)
            	select to_jsonb(date '2014-05-28');
	       ^
<sql-statement>
select to_jsonb(date 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(date 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(date 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (date)
            	select to_jsonb(date 'Infinity');
	       ^
<sql-statement>
select to_jsonb(date '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(date '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(date '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (date)
            	select to_jsonb(date '-Infinity');
	       ^
<sql-statement>
select to_jsonb(timestamp 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamp 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamp 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamp)
            	select to_jsonb(timestamp 'Infinity');
	       ^
<sql-statement>
select to_jsonb(timestamp '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamp '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamp '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamp)
            	select to_jsonb(timestamp '-Infinity');
	       ^
<sql-statement>
select to_jsonb(timestamptz 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamptz 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamptz 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamptz)
            	select to_jsonb(timestamptz 'Infinity');
	       ^
<sql-statement>
select to_jsonb(timestamptz '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamptz '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamptz '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamptz)
            	select to_jsonb(timestamptz '-Infinity');
	       ^
<sql-statement>
--jsonb_agg
SELECT jsonb_agg(q)
  FROM ( SELECT $$a$$ || x AS b, y AS c,
               ARRAY[ROW(x.*,ARRAY[1,2,3]),
               ROW(y.*,ARRAY[4,5,6])] AS z
         FROM generate_series(1,2) x,
              generate_series(4,5) y) q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:16: Error: alternative is not implemented yet : 138
    	               ARRAY[ROW(x.*,ARRAY[1,2,3]),
	               ^
<sql-statement>
SELECT jsonb_agg(q ORDER BY x, y)
  FROM rows q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	SELECT jsonb_agg(q ORDER BY x, y)
	       ^
<sql-statement>
UPDATE rows SET x = NULL WHERE x = 1;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys'. 
    
<sql-statement>
SELECT jsonb_agg(q ORDER BY x NULLS FIRST, y)
  FROM rows q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	SELECT jsonb_agg(q ORDER BY x NULLS FIRST, y)
	       ^
<sql-statement>
-- jsonb extraction functions
CREATE TEMP TABLE test_jsonb (
       json_type text,
       test_json jsonb
);
</sql-statement>
<sql-statement>
INSERT INTO test_jsonb VALUES
('scalar','"a scalar"'),
('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
('object','{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
</sql-statement>
<sql-statement>
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json -> 'field2' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> 9 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 6 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 7 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field4' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field5' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field6' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
	       ^
<sql-statement>
SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
	       ^
<sql-statement>
SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'object';
	       ^
<sql-statement>
-- nulls
SELECT (test_json->'field3') IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT (test_json->>'field3') IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT (test_json->3) IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT (test_json->>3) IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
-- corner cases
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::text;
</sql-statement>
BackTrace(void**, unsigned long)+29 (0x14033ECD)
TBackTrace::Capture()+30 (0x1403443E)
TWithBackTrace<yexception>::TWithBackTrace<>()+72 (0x13FD0568)
NYT::TNode::TTypeError::TTypeError()+25 (0x144DC3E9)
NYT::TNode::CheckType(NYT::TNode::EType) const+267 (0x144DD9BB)
NYT::TNode::AsString() const+30 (0x144DC53E)
WriteTableToStream(IOutputStream&, TVector<NYT::TNode, std::__y1::allocator<NYT::TNode> > const&, TVector<NYT::TNode, std::__y1::allocator<NYT::TNode> > const&)+830 (0x13EBBB7E)
Main(int, char**)+5748 (0x13EC0FB4)
main+273 (0x13EC2761)
??+0 (0x7F5FC2629D90)
__libc_start_main+128 (0x7F5FC2629E40)
??+0 (0x13E4C029)

(NYT::TNode::TTypeError) library/cpp/yson/node/node.cpp:829: TNode type string_node expected, actual type null
